From 4a03ec520a8393b5edaf9daa5a389ed72a1157c5 Mon Sep 17 00:00:00 2001
From: Paulo Assis <pj.assis@gmail.com>
Date: Thu, 23 Mar 2017 14:37:05 +0000
Subject: [PATCH] update to new libavcodec API with decoupled input/output;
 drop support for libavcodec versions older than 57.16

---
 configure.ac                       |   7 +-
 guvcview/Makefile.am               |   6 +-
 gview_encoder/encoder.c            | 266 +++++++++++++++++++------------------
 gview_encoder/encoder.h            |  38 +-----
 gview_render/render_osd_vu_meter.c |  20 +--
 gview_v4l2core/frame_decoder.c     |  92 ++++++++-----
 gview_v4l2core/frame_decoder.h     |  28 +++-
 gview_v4l2core/jpeg_decoder.c      |  83 ++++--------
 gview_v4l2core/uvc_h264.c          |  76 ++++-------
 9 files changed, 298 insertions(+), 318 deletions(-)

diff --git a/configure.ac b/configure.ac
index f057191..8bde1a9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -10,7 +10,7 @@ dnl Initialization macros (sets PACKAGE and VERSION)
 dnl --------------------------------
 m4_define([guvcview_major], [2])
 m4_define([guvcview_minor], [0])
-m4_define([guvcview_micro], [5])
+m4_define([guvcview_micro], [6])
 
 m4_define([guvcview_version],
           [guvcview_major.guvcview_minor.guvcview_micro])
@@ -44,7 +44,7 @@ rm -f config.cache; touch config.cache
 AC_PREFIX_DEFAULT(/usr/local)
 
 # check for clang first
-# gcc will still be used if clang not installed 
+# gcc will still be used if clang not installed
 AC_PROG_CC([clang gcc cc])
 AM_PROG_CC_C_O
 AC_PROG_CXX([clang++ g++ cc++ cxx])
@@ -132,7 +132,7 @@ dnl --------------------------------------------------------------------------
 dnl check for libgviewv4l2core dependencies
 dnl --------------------------------------------------------------------------
 
-PKG_CHECK_MODULES(GVIEWV4L2CORE, [libv4l2 libudev libusb-1.0 libavcodec libavutil libpng])
+PKG_CHECK_MODULES(GVIEWV4L2CORE, [libv4l2 libudev libusb-1.0 libavcodec >= 57.16 libavutil libpng])
 AC_SUBST(GVIEWV4L2CORE_CFLAGS)
 AC_SUBST(GVIEWV4L2CORE_LIBS)
 
@@ -532,4 +532,3 @@ AC_MSG_NOTICE([
   debian menu      : ${enable_debian_menu}
 
 ])
-
diff --git a/guvcview/Makefile.am b/guvcview/Makefile.am
index c2cfd98..ed4f0b7 100644
--- a/guvcview/Makefile.am
+++ b/guvcview/Makefile.am
@@ -1,6 +1,7 @@
 ## Process this file with automake to produce Makefile.in
 
 #AM_CFLAGS =
+AM_CXXFLAGS = -std=c++11
 
 bin_PROGRAMS = guvcview
 
@@ -54,7 +55,7 @@ if HAVE_QT5
 guvcview_CPPFLAGS = $(guvcview_CFLAGS) \
 					$(GUIQT5_CFLAGS) \
 					-fPIC
-endif		  
+endif
 
 guvcview_LDFLAGS = $(LIBINTL)
 
@@ -77,6 +78,3 @@ moc_%.cpp: %.hpp
 
 localedir = $(datadir)/locale
 DEFS = -DLOCALEDIR=\"$(localedir)\" @DEFS@
-
-
-
diff --git a/gview_encoder/encoder.c b/gview_encoder/encoder.c
index 9968075..fd66e88 100644
--- a/gview_encoder/encoder.c
+++ b/gview_encoder/encoder.c
@@ -176,8 +176,8 @@ static void encoder_clean_video_ring_buffer()
  */
 void __attribute__ ((constructor)) gviewencoder_init()
 {
-#if !LIBAVCODEC_VER_AT_LEAST(54,01)
-	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 54.01)\n");
+#if !LIBAVCODEC_VER_AT_LEAST(57,16)
+	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 57.16)\n");
 	return;
 #endif
 	//printf("ENCODER: constructor function called\n");
@@ -325,9 +325,9 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 {
 	//assertions
 	assert(encoder_ctx != NULL);
-	
-#if !LIBAVCODEC_VER_AT_LEAST(54,01)
-	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 54.01)\n");
+
+#if !LIBAVCODEC_VER_AT_LEAST(57,16)
+	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 57.16)\n");
 	return NULL;
 #else
 	if(encoder_ctx->video_codec_ind < 0)
@@ -371,7 +371,7 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 	}
 
 	/*
-	 * alloc the video codec data 
+	 * alloc the video codec data
 	 */
 	encoder_codec_data_t *video_codec_data = calloc(1, sizeof(encoder_codec_data_t));
 	if(video_codec_data == NULL)
@@ -395,7 +395,7 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 		fprintf(stderr, "ENCODER: libav video codec (%i) not found - using raw input\n",video_defaults->codec_id);
 		video_defaults = encoder_get_video_codec_defaults(0);
 		encoder_set_raw_video_input(encoder_ctx, video_defaults);
-		
+
 		//alloc outbuf
 		if(enc_video_ctx->outbuf_size <= 0)
 			enc_video_ctx->outbuf_size = 240000;//1792
@@ -442,26 +442,17 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 	video_codec_data->codec_context->trellis = video_defaults->trellis;
 
 	/*motion estimation method */
-#if !LIBAVCODEC_VER_AT_LEAST(56,60)
-	video_codec_data->codec_context->me_method = video_defaults->me_method;
-#else
 	if( video_defaults->codec_id == AV_CODEC_ID_H264 && video_defaults->me_method > 4)
 		video_defaults->me_method = X264_ME_HEX;
 
 	av_dict_set_int(&video_codec_data->private_options, "motion-est", video_defaults->me_method, 0);
-#endif
-
-#if !LIBAVCODEC_VER_AT_LEAST(57,00)
-	video_codec_data->codec_context->pre_me = video_defaults->pre_me;
-	video_codec_data->codec_context->mpeg_quant = video_defaults->mpeg_quant; //h.263
-#else
 	av_dict_set_int(&video_codec_data->private_options, "mpeg_quant", video_defaults->mpeg_quant, 0);
 	av_dict_set_int(&video_codec_data->private_options, "mepre", video_defaults->pre_me, 0);
-#endif
+
 
 	video_codec_data->codec_context->dia_size = video_defaults->dia;
 	video_codec_data->codec_context->pre_dia_size = video_defaults->pre_dia;
-	
+
 	video_codec_data->codec_context->me_pre_cmp = video_defaults->me_pre_cmp;
 	video_codec_data->codec_context->me_cmp = video_defaults->me_cmp;
 	video_codec_data->codec_context->me_sub_cmp = video_defaults->me_sub_cmp;
@@ -469,7 +460,7 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 	video_codec_data->codec_context->refs = video_defaults->framerefs;         //NEW
 	video_codec_data->codec_context->last_predictor_count = video_defaults->last_pred;
 
-	
+
 	video_codec_data->codec_context->qmin = video_defaults->qmin;             // best detail allowed - worst compression
 	video_codec_data->codec_context->qmax = video_defaults->qmax;             // worst detail allowed - best compression
 	video_codec_data->codec_context->max_qdiff = video_defaults->max_qdiff;
@@ -502,14 +493,14 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 	   //av_dict_set(&video_codec_data->private_options, "rc_lookahead", "1", 0);
 	   av_dict_set(&video_codec_data->private_options, "crf", "23", 0);
 	}
-#if LIBAVCODEC_VER_AT_LEAST(55,24)
+
 	if(video_defaults->codec_id == AV_CODEC_ID_HEVC)
 	{
 	   video_codec_data->codec_context->me_range = 16;
 	   av_dict_set(&video_codec_data->private_options, "crf", "28", 0);
 	   av_dict_set(&video_codec_data->private_options, "preset", "ultrafast", 0);
 	}
-#endif
+
 	int ret = 0;
 	/* open codec*/
 	if ((ret = avcodec_open2(
@@ -525,7 +516,7 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 		free(video_codec_data);
 		video_defaults = encoder_get_video_codec_defaults(0);
 		encoder_set_raw_video_input(encoder_ctx, video_defaults);
-		
+
 		//alloc outbuf
 		if(enc_video_ctx->outbuf_size <= 0)
 			enc_video_ctx->outbuf_size = 240000;//1792
@@ -537,15 +528,12 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 			fprintf(stderr, "ENCODER: FATAL memory allocation failure (encoder_video_init): %s\n", strerror(errno));
 			exit(-1);
 		}
-	
+
 		return (enc_video_ctx);
 	}
 
-#if LIBAVCODEC_VER_AT_LEAST(55,28)
 	video_codec_data->frame = av_frame_alloc();
-#else
-	video_codec_data->frame = avcodec_alloc_frame();
-#endif
+
 	if(video_codec_data->frame == NULL)
 	{
 		fprintf(stderr, "ENCODER: FATAL memory allocation failure (encoder_video_init): %s\n", strerror(errno));
@@ -553,6 +541,14 @@ static encoder_video_context_t *encoder_video_init(encoder_context_t *encoder_ct
 	}
 	video_codec_data->frame->pts = 0;
 
+	video_codec_data->outpkt = av_packet_alloc();
+
+	if(video_codec_data->outpkt == NULL)
+	{
+		fprintf(stderr, "ENCODER: FATAL memory allocation failure (encoder_video_init): %s\n", strerror(errno));
+		exit(-1);
+	}
+
 	/*set the codec data in codec context*/
 	enc_video_ctx->codec_data = (void *) video_codec_data;
 
@@ -598,9 +594,9 @@ static encoder_audio_context_t *encoder_audio_init(encoder_context_t *encoder_ct
 {
 	//assertions
 	assert(encoder_ctx != NULL);
-	
-#if !LIBAVCODEC_VER_AT_LEAST(54,01)
-	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 54.01)");
+
+#if !LIBAVCODEC_VER_AT_LEAST(57,16)
+	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 57.16)");
 	return NULL;
 #else
 
@@ -637,7 +633,7 @@ static encoder_audio_context_t *encoder_audio_init(encoder_context_t *encoder_ct
 	}
 
 	encoder_ctx->enc_audio_ctx = enc_audio_ctx;
-	
+
 	enc_audio_ctx->flushed_buffers = 0;
 	enc_audio_ctx->flush_delayed_frames = 0;
 	enc_audio_ctx->flush_done = 0;
@@ -695,7 +691,7 @@ static encoder_audio_context_t *encoder_audio_init(encoder_context_t *encoder_ct
     audio_codec_data->codec_context->codec_id = audio_defaults->codec_id;
 
 	audio_codec_data->codec_context->codec_type = AVMEDIA_TYPE_AUDIO;
-	
+
 	audio_codec_data->codec_context->time_base = (AVRational){1, encoder_ctx->audio_samprate};
 
 	/*check if codec supports sample format*/
@@ -822,11 +818,7 @@ static encoder_audio_context_t *encoder_audio_init(encoder_context_t *encoder_ct
 		exit(-1);
 	}
 
-#if LIBAVCODEC_VER_AT_LEAST(55,28)
 	audio_codec_data->frame = av_frame_alloc();
-#else
-	audio_codec_data->frame = avcodec_alloc_frame();
-#endif
 
 	if(audio_codec_data->frame == NULL)
 	{
@@ -834,11 +826,15 @@ static encoder_audio_context_t *encoder_audio_init(encoder_context_t *encoder_ct
 		exit(-1);
 	}
 
-#if LIBAVCODEC_VER_AT_LEAST(55,28)
 	av_frame_unref(audio_codec_data->frame);
-#else
-	avcodec_get_frame_defaults(audio_codec_data->frame);
-#endif
+
+	audio_codec_data->outpkt = av_packet_alloc();
+
+	if(audio_codec_data->outpkt == NULL)
+	{
+		fprintf(stderr, "ENCODER: FATAL memory allocation failure (encoder_audio_init): %s\n", strerror(errno));
+		exit(-1);
+	}
 
 	audio_codec_data->frame->nb_samples = frame_size;
 	audio_codec_data->frame->format = audio_defaults->sample_format;
@@ -871,7 +867,7 @@ int encoder_get_audio_frame_size(encoder_context_t *encoder_ctx)
 		return -1;
 
 	encoder_codec_data_t *audio_codec_data = (encoder_codec_data_t *) encoder_ctx->enc_audio_ctx->codec_data;
-	
+
 	if(audio_codec_data == NULL)
 		return -1;
 
@@ -928,7 +924,7 @@ int encoder_get_audio_sample_fmt(encoder_context_t *encoder_ctx)
  * get audio sample format max value
  * args:
  *   none
- * 
+ *
  * returns the maximum audio sample format value
  */
 int encoder_get_max_audio_sample_fmt()
@@ -1240,7 +1236,7 @@ int encoder_flush_video_buffer(encoder_context_t *encoder_ctx)
 
 	int buffer_count = video_ring_buffer_size;
 	int flushed_frame_counter = buffer_count;
-	
+
 	if(verbosity > 1)
 		printf("ENCODER: flushing video buffer with %i frames\n", buffer_count);
 
@@ -1255,7 +1251,7 @@ int encoder_flush_video_buffer(encoder_context_t *encoder_ctx)
 		flag = video_ring_buffer[video_read_index].flag;
 		__UNLOCK_MUTEX ( __PMUTEX );
 	}
-	
+
 	if(verbosity > 1)
 		printf("ENCODER: processed remaining %i video frames\n", flushed_frame_counter - buffer_count);
 
@@ -1300,17 +1296,17 @@ int encoder_flush_audio_buffer(encoder_context_t *encoder_ctx)
 	/*flush libav*/
 	int flushed_frame_counter = 0;
 	encoder_ctx->enc_audio_ctx->flush_delayed_frames  = 1;
-	
+
 	while(!encoder_ctx->enc_audio_ctx->flush_done)
 	{
 		encoder_encode_audio(encoder_ctx, NULL);
 		encoder_write_audio_data(encoder_ctx);
 		flushed_frame_counter++;
 	}
-	
+
 	if(verbosity > 1)
 		printf("ENCODER: flushed %i delayed audio frames\n", flushed_frame_counter);
-	
+
 	return 0;
 }
 
@@ -1355,12 +1351,12 @@ static int store_video_df_pts(encoder_video_context_t *enc_video_ctx)
 {
 	/*assertions*/
 	assert(enc_video_ctx != NULL);
-	
+
 	if(enc_video_ctx->write_df < 0)
 		enc_video_ctx->write_df = 0;
 	else
 		enc_video_ctx->write_df++;
-	
+
 	if(enc_video_ctx->write_df == enc_video_ctx->read_df)
 	{
 		fprintf(stderr, "ENCODER: Maximum of %i delayed video frames reached...\n", MAX_DELAYED_FRAMES);
@@ -1382,7 +1378,7 @@ static int store_video_df_pts(encoder_video_context_t *enc_video_ctx)
 	}
 
 	enc_video_ctx->delayed_pts[enc_video_ctx->write_df] = enc_video_ctx->pts;
-	
+
 	return enc_video_ctx->write_df;
 }
 
@@ -1418,9 +1414,9 @@ static int read_video_df_pts(encoder_video_context_t *enc_video_ctx)
 
 	//read the delayed frame pts
 	enc_video_ctx->pts = enc_video_ctx->delayed_pts[enc_video_ctx->read_df];
-	
+
 	if(enc_video_ctx->flush_delayed_frames && verbosity > 1)
-		printf("ENCODER: video codec flushing delayed frame %i ( pts: %" PRId64 " )\n", 
+		printf("ENCODER: video codec flushing delayed frame %i ( pts: %" PRId64 " )\n",
 			enc_video_ctx->read_df, enc_video_ctx->pts);
 
 	if(enc_video_ctx->read_df == enc_video_ctx->write_df)
@@ -1434,6 +1430,29 @@ static int read_video_df_pts(encoder_video_context_t *enc_video_ctx)
 	return enc_video_ctx->read_df;
 }
 
+
+static int libav_encode(AVCodecContext *avctx, AVPacket *pkt, AVFrame *frame, int *got_packet)
+{
+	int ret;
+
+  *got_packet = 0;
+
+	if(frame)
+	{
+		ret = avcodec_send_frame(avctx, frame);
+  	if (ret < 0)
+  		return ret; //if (ret == AVERROR(EAGAIN)) //input buffer is full
+	}
+
+  ret = avcodec_receive_packet(avctx, pkt);
+  if (!ret)
+  	*got_packet = 1;
+  if (ret == AVERROR(EAGAIN)) //output buffer is empty
+  	return 0;
+
+  return ret;
+}
+
 /*
  * encode video frame
  * args:
@@ -1450,11 +1469,11 @@ int encoder_encode_video(encoder_context_t *encoder_ctx, void *input_frame)
 	/*assertions*/
 	assert(encoder_ctx != NULL);
 
-#if !LIBAVCODEC_VER_AT_LEAST(54, 01)
-	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 54.01)\n");
+#if !LIBAVCODEC_VER_AT_LEAST(57, 16)
+	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 57.16)\n");
 	return 0;
 #else
-	
+
 	encoder_video_context_t *enc_video_ctx = encoder_ctx->enc_video_ctx;
 
 	int outsize = 0;
@@ -1518,7 +1537,7 @@ int encoder_encode_video(encoder_context_t *encoder_ctx, void *input_frame)
 		video_codec_data->frame->pts +=
 			(video_codec_data->codec_context->time_base.num * 1000 / video_codec_data->codec_context->time_base.den) * 90;
 	}
-	
+
 	if(enc_video_ctx->flush_delayed_frames)
 	{
 		if(!enc_video_ctx->flushed_buffers)
@@ -1529,12 +1548,8 @@ int encoder_encode_video(encoder_context_t *encoder_ctx, void *input_frame)
  	}
 
 	/* encode the video */
-	AVPacket pkt;
-    int got_packet = 0;
-    av_init_packet(&pkt);
-	pkt.data = enc_video_ctx->outbuf;
-	pkt.size = enc_video_ctx->outbuf_size;
-
+	AVPacket *pkt = video_codec_data->outpkt;
+	int got_packet = 0;
 	int ret = 0;
     //if(enc_video_ctx->outbuf_size < FF_MIN_BUFFER_SIZE)
     //{
@@ -1542,15 +1557,15 @@ int encoder_encode_video(encoder_context_t *encoder_ctx, void *input_frame)
     //    return -1;
     //}
  	if(!enc_video_ctx->flush_delayed_frames)
-    	ret = avcodec_encode_video2(
+    	ret = libav_encode(
 			video_codec_data->codec_context,
-			&pkt,
+			pkt,
 			video_codec_data->frame,
 			&got_packet);
    	else
-   		ret = avcodec_encode_video2(
+   		ret = libav_encode(
 			video_codec_data->codec_context,
-			&pkt, NULL, /*NULL flushes the encoder buffers*/
+			pkt, NULL, /*NULL flushes the encoder buffers*/
 			&got_packet);
 
 	if(ret < 0)
@@ -1565,21 +1580,27 @@ int encoder_encode_video(encoder_context_t *encoder_ctx, void *input_frame)
 		//	printf("ENCODER: (video) pts:%" PRId64 " dts:%" PRId64 "\n", pkt.pts, pkt.dts);
 		//else
 		//	printf("ENCODER: (video) no pts set\n");
-		enc_video_ctx->dts = pkt.dts;
-		enc_video_ctx->flags = pkt.flags;
-		enc_video_ctx->duration = pkt.duration;
+		enc_video_ctx->dts = pkt->dts;
+		enc_video_ctx->flags = pkt->flags;
+		enc_video_ctx->duration = pkt->duration;
+
+		if(pkt->size <= enc_video_ctx->outbuf_size)
+			memcpy(enc_video_ctx->outbuf, pkt->data, pkt->size);
+		else
+			fprintf(stderr, "video packet size is bigger than output buffer(%i>%i)\n",pkt->size, enc_video_ctx->outbuf_size);
 
     	/* free any side data since we cannot return it */
-    	if (pkt.side_data_elems > 0)
+    	if (pkt->side_data_elems > 0)
     	{
     		int i;
-        	for (i = 0; i < pkt.side_data_elems; i++)
-        		av_free(pkt.side_data[i].data);
-        	av_freep(&pkt.side_data);
-        	pkt.side_data_elems = 0;
+        	for (i = 0; i < pkt->side_data_elems; i++)
+        		av_free(pkt->side_data[i].data);
+        	av_freep(&pkt->side_data);
+        	pkt->side_data_elems = 0;
     	}
+    	outsize = pkt->size;
 
-    	outsize = pkt.size;
+			av_packet_unref(pkt);
     }
 
 	if(enc_video_ctx->flush_delayed_frames && ((outsize == 0) || !got_packet))
@@ -1612,8 +1633,8 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
 	/*assertions*/
 	assert(encoder_ctx != NULL);
 
-#if !LIBAVCODEC_VER_AT_LEAST(54, 01)
-	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 54.01)\n");
+#if !LIBAVCODEC_VER_AT_LEAST(57, 16)
+	fprintf(stderr, "ENCODER: Error - libavcodec version not supported (minimum 57.16)\n");
 	return outsize;
 #else
 
@@ -1628,7 +1649,7 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
 
 		return outsize;
 	}
-	
+
 	encoder_codec_data_t *audio_codec_data = (encoder_codec_data_t *) enc_audio_ctx->codec_data;
 
 	if(enc_audio_ctx->flush_delayed_frames)
@@ -1643,25 +1664,19 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
  	}
 
 	/* encode the audio */
-	AVPacket pkt;
+	/* encode the video */
+	AVPacket *pkt = audio_codec_data->outpkt;
 	int got_packet = 0;
-	av_init_packet(&pkt);
-	pkt.data = enc_audio_ctx->outbuf;
-	pkt.size = enc_audio_ctx->outbuf_size;
-
 	int ret = 0;
 
+
 	if(!enc_audio_ctx->flush_delayed_frames)
 	{
 		/*number of samples per channel*/
 		audio_codec_data->frame->nb_samples  = audio_codec_data->codec_context->frame_size;
 		audio_codec_data->frame->pts = enc_audio_ctx->pts;
 
-#if LIBAVUTIL_VER_AT_LEAST(51,23)
 		int align = 0;
-#else
-		int align = 1; /*otherwise it causes a SIGFPE*/
-#endif
 
 		int buffer_size = av_samples_get_buffer_size(
 			NULL,
@@ -1672,16 +1687,16 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
 
 		if(buffer_size <= 0)
 		{
-			fprintf(stderr, "ENCODER: (encoder_encode_audio) av_samples_get_buffer_size error (%d): chan(%d) nb_samp(%d) samp_fmt(%d)\n", 
-				buffer_size, 
-				audio_codec_data->codec_context->channels, 
-				audio_codec_data->frame->nb_samples, 
+			fprintf(stderr, "ENCODER: (encoder_encode_audio) av_samples_get_buffer_size error (%d): chan(%d) nb_samp(%d) samp_fmt(%d)\n",
+				buffer_size,
+				audio_codec_data->codec_context->channels,
+				audio_codec_data->frame->nb_samples,
 				audio_codec_data->codec_context->sample_fmt);
 
 			return outsize;
 		}
 
-		
+
 		/*set the data pointers in frame*/
 		ret = avcodec_fill_audio_frame(
 			audio_codec_data->frame,
@@ -1690,16 +1705,16 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
 			(const uint8_t *) audio_data,
 			buffer_size,
 			align);
-		
+
 		if(ret < 0)
 		{
-			fprintf(stderr, "ENCODER: (encoder_encode_audio) avcodec_fill_audio_frame error (%d): chan(%d) nb_samp(%d) samp_fmt(%d) buff(%d bytes)\n", 
-				ret, 
-				audio_codec_data->codec_context->channels, 
-				audio_codec_data->frame->nb_samples, 
+			fprintf(stderr, "ENCODER: (encoder_encode_audio) avcodec_fill_audio_frame error (%d): chan(%d) nb_samp(%d) samp_fmt(%d) buff(%d bytes)\n",
+				ret,
+				audio_codec_data->codec_context->channels,
+				audio_codec_data->frame->nb_samples,
 				audio_codec_data->codec_context->sample_fmt,
 				buffer_size);
-			
+
 			return outsize;
 		}
 
@@ -1714,17 +1729,17 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
 				 audio_codec_data->codec_context->time_base.den);
 		}
 
-		ret = avcodec_encode_audio2(
+		ret = libav_encode(
 				audio_codec_data->codec_context,
-				&pkt,
+				pkt,
 				audio_codec_data->frame,
 				&got_packet);
 	}
 	else
 	{
-		ret = avcodec_encode_audio2(
+		ret = libav_encode(
 			audio_codec_data->codec_context,
-			&pkt,
+			pkt,
 			NULL, /*NULL flushes the encoder buffers*/
 			&got_packet);
 	}
@@ -1736,12 +1751,17 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
 		//else
 		//	printf("ENCODER: (audio) no pts set\n");
 
-		if(pkt.pts < 0) //avoid negative pts
-			pkt.pts = -pkt.pts;
-		enc_audio_ctx->pts = pkt.pts;
-		enc_audio_ctx->dts = pkt.dts;
-		enc_audio_ctx->flags = pkt.flags;
-		enc_audio_ctx->duration = pkt.duration;
+		if(pkt->pts < 0) //avoid negative pts
+			pkt->pts = -pkt->pts;
+		enc_audio_ctx->pts = pkt->pts;
+		enc_audio_ctx->dts = pkt->dts;
+		enc_audio_ctx->flags = pkt->flags;
+		enc_audio_ctx->duration = pkt->duration;
+
+		if(pkt->size <= enc_audio_ctx->outbuf_size)
+			memcpy(enc_audio_ctx->outbuf, pkt->data, pkt->size);
+		else
+			fprintf(stderr, "audio packet size is bigger than output buffer(%i>%i)\n",pkt->size, enc_audio_ctx->outbuf_size);
 
 		/* free any side data since we cannot return it */
 		//ff_packet_free_side_data(&pkt);
@@ -1749,7 +1769,9 @@ int encoder_encode_audio(encoder_context_t *encoder_ctx, void *audio_data)
 			audio_codec_data->frame->extended_data != audio_codec_data->frame->data)
 			av_freep(audio_codec_data->frame->extended_data);
 
-		outsize = pkt.size;
+		outsize = pkt->size;
+		
+		av_packet_unref(pkt);
 	}
 
 	last_audio_pts = enc_audio_ctx->pts;
@@ -1807,16 +1829,12 @@ void encoder_close(encoder_context_t *encoder_ctx)
 			av_dict_free(&(video_codec_data->private_options));
 
 			if(video_codec_data->frame)
-#if LIBAVCODEC_VER_AT_LEAST(55,28)
 				av_frame_free(&video_codec_data->frame);
-#else
-	#if LIBAVCODEC_VER_AT_LEAST(54,28)
-				avcodec_free_frame(&video_codec_data->frame);
-	#else
-				av_freep(&video_codec_data->frame);
-	#endif
-#endif
-			free(video_codec_data);		
+
+			if(video_codec_data->outpkt)
+				av_packet_free(&video_codec_data->outpkt);
+
+			free(video_codec_data);
 		}
 
 		if(enc_video_ctx->priv_data)
@@ -1841,15 +1859,11 @@ void encoder_close(encoder_context_t *encoder_ctx)
 			free(audio_codec_data->codec_context);
 
 			if(audio_codec_data->frame)
-#if LIBAVCODEC_VER_AT_LEAST(55,28)
 				av_frame_free(&audio_codec_data->frame);
-#else
-	#if LIBAVCODEC_VER_AT_LEAST(54,28)
-				avcodec_free_frame(&audio_codec_data->frame);
-	#else
-				av_freep(&audio_codec_data->frame);
-	#endif
-#endif
+
+			if(audio_codec_data->outpkt)
+				av_packet_free(&audio_codec_data->outpkt);
+
 			free(audio_codec_data);
 		}
 
diff --git a/gview_encoder/encoder.h b/gview_encoder/encoder.h
index b8f2d2b..11c9522 100644
--- a/gview_encoder/encoder.h
+++ b/gview_encoder/encoder.h
@@ -37,7 +37,7 @@
 #include <libavutil/version.h>
 	#endif
 #include <libavutil/avutil.h>
-#endif 
+#endif
 
 #define LIBAVCODEC_VER_AT_LEAST(major,minor)  (LIBAVCODEC_VERSION_MAJOR > major || \
                                               (LIBAVCODEC_VERSION_MAJOR == major && \
@@ -55,34 +55,6 @@
 #define X264_ME_HEX 1
 #endif
 
-#if !LIBAVCODEC_VER_AT_LEAST(53,0)
-  #define AV_SAMPLE_FMT_S16 SAMPLE_FMT_S16
-  #define AV_SAMPLE_FMT_FLT SAMPLE_FMT_FLT
-#endif
-
-
-#if !LIBAVCODEC_VER_AT_LEAST(54,25)
-	#define AV_CODEC_ID_NONE CODEC_ID_NONE
-	#define AV_CODEC_ID_MJPEG CODEC_ID_MJPEG
-	#define AV_CODEC_ID_MPEG1VIDEO CODEC_ID_MPEG1VIDEO
-	#define AV_CODEC_ID_FLV1 CODEC_ID_FLV1
-	#define AV_CODEC_ID_WMV1 CODEC_ID_WMV1
-	#define AV_CODEC_ID_MPEG2VIDEO CODEC_ID_MPEG2VIDEO
-	#define AV_CODEC_ID_MSMPEG4V3 CODEC_ID_MSMPEG4V3
-	#define AV_CODEC_ID_MPEG4 CODEC_ID_MPEG4
-	#define AV_CODEC_ID_H264 CODEC_ID_H264
-	#define AV_CODEC_ID_VP8 CODEC_ID_VP8
-	#define AV_CODEC_ID_THEORA CODEC_ID_THEORA
-
-	#define AV_CODEC_ID_PCM_S16LE CODEC_ID_PCM_S16LE
-	#define AV_CODEC_ID_PCM_F32LE CODEC_ID_PCM_F32LE
-	#define AV_CODEC_ID_MP2 CODEC_ID_MP2
-	#define AV_CODEC_ID_MP3 CODEC_ID_MP3
-	#define AV_CODEC_ID_AC3 CODEC_ID_AC3
-	#define AV_CODEC_ID_AAC CODEC_ID_AAC
-	#define AV_CODEC_ID_VORBIS CODEC_ID_VORBIS
-#endif
-
 #if !LIBAVUTIL_VER_AT_LEAST(52,0)
 	#define AV_PIX_FMT_NONE     PIX_FMT_NONE
 	#define AV_PIX_FMT_YUVJ420P PIX_FMT_YUVJ420P
@@ -153,15 +125,13 @@
 
 /*
  * codec data struct used for encoder context
- * we set all avcodec stuff here so that we don't 
+ * we set all avcodec stuff here so that we don't
  * need to export any of it's symbols in the public API
  */
 typedef struct _encoder_codec_data_t
 {
 	AVCodec *codec;
-#if LIBAVCODEC_VER_AT_LEAST(53,6)
 	AVDictionary *private_options;
-#endif
 	AVCodecContext *codec_context;
 	AVFrame *frame;
 	AVPacket *outpkt;
@@ -214,14 +184,14 @@ int avpriv_split_xiph_headers(
 		int first_header_size,
 		uint8_t *header_start[3],
         int header_len[3]);
-	
+
 /*
  * set yu12 frame in codec data frame
  * args:
  *    video_codec_data - pointer to video codec data
  *    inp - input data (yu12)
  *    width - frame width
- *    height - frame height 
+ *    height - frame height
  *
  * asserts:
  *    video_codec_data is not null
diff --git a/gview_render/render_osd_vu_meter.c b/gview_render/render_osd_vu_meter.c
index 1f19121..e3c7e3b 100644
--- a/gview_render/render_osd_vu_meter.c
+++ b/gview_render/render_osd_vu_meter.c
@@ -33,9 +33,9 @@ extern int verbosity;
 
 typedef struct _yuv_color_t
 {
-	int8_t y;
-	int8_t u;
-	int8_t v;
+	uint8_t y;
+	uint8_t u;
+	uint8_t v;
 } yuv_color_t;
 
 #define REFERENCE_LEVEL 0.8
@@ -78,13 +78,13 @@ static void plot_box_yu12(uint8_t *frame, int lines, int linesize, int x, int y,
 			*py++ = color->y;
 		}
 	}
-				
+
 	/*u v*/
 	for(h = 0; h < height/2; h++) /*every two lines*/
 	{
 		pu = frame + (linesize * lines) + (int) floor(x/2) + (( (int) floor(y/2) + h) * (int) floor(linesize/2));
 		pv = pu + (int) floor((linesize * lines) / 4);
-					
+
 		int w = 0;
 		for(w = 0; w < width/2; w++) /*every two rows*/
 		{
@@ -117,14 +117,14 @@ static void plot_line_yu12(uint8_t *frame, int lines, int linesize, int x, int y
 	uint8_t *pv = pu + ((linesize * lines) / 4);
 
 	int w = 0;
-	
+
 	/*y*/
 	py = frame + x + (y * linesize);
 	for(w = 0; w < width; ++w)
 	{
 		*py++ = color->y;
 	}
-				
+
 	/*u v*/
 	pu = frame + (linesize * lines) + (int) floor(x/2) + ((int) floor(y/2) * (int) floor(linesize/2));
 	pv = pu + (int) floor((linesize * lines) / 4);
@@ -132,7 +132,7 @@ static void plot_line_yu12(uint8_t *frame, int lines, int linesize, int x, int y
 	{
 		*pu++ = color->u;
 		*pv++ = color->v;
-	}	
+	}
 }
 
 /*
@@ -212,13 +212,13 @@ void render_osd_vu_meter(uint8_t *frame, int width, int height, float vu_level[2
 			/*green bar*/
 			if (db < -10)
 			{
-				color.y = 154;
+					color.y = 154;
   				color.u = 72;
   				color.v = 57;
 			}
 			else if (db < -2) /*yellow bar*/
 			{
-				color.y = 203;
+					color.y = 203;
   				color.u = 44;
   				color.v = 142;
 			}
diff --git a/gview_v4l2core/frame_decoder.c b/gview_v4l2core/frame_decoder.c
index 30a653c..5e9e041 100644
--- a/gview_v4l2core/frame_decoder.c
+++ b/gview_v4l2core/frame_decoder.c
@@ -85,19 +85,19 @@ int alloc_v4l2_frames(v4l2_dev_t *vd)
 				return ret;
 			}
 
-			
+
 			/*frame queue*/
 			for(i=0; i<vd->frame_queue_size; ++i)
 			{
 				vd->frame_queue[i].h264_frame_max_size = width * height; /*1 byte per pixel*/
 				vd->frame_queue[i].h264_frame = calloc(vd->frame_queue[i].h264_frame_max_size, sizeof(uint8_t));
-			
+
 				if(vd->frame_queue[i].h264_frame == NULL)
 				{
 					fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (alloc_v4l2_frames): %s\n", strerror(errno));
 					exit(-1);
 				}
-				
+
 				vd->frame_queue[i].yuv_frame = calloc(framesizeIn, sizeof(uint8_t));
 				if(vd->frame_queue[i].yuv_frame == NULL)
 				{
@@ -106,7 +106,7 @@ int alloc_v4l2_frames(v4l2_dev_t *vd)
 				}
 
 			}
-			
+
 			vd->h264_last_IDR = calloc(width * height, sizeof(uint8_t));
 			if(vd->h264_last_IDR == NULL)
 			{
@@ -114,7 +114,7 @@ int alloc_v4l2_frames(v4l2_dev_t *vd)
 				exit(-1);
 			}
 			vd->h264_last_IDR_size = 0; /*reset (no frame stored)*/
-						
+
 			break;
 
 		case V4L2_PIX_FMT_JPEG:
@@ -127,7 +127,7 @@ int alloc_v4l2_frames(v4l2_dev_t *vd)
 				fprintf(stderr, "V4L2_CORE: couldn't init jpeg decoder\n");
 				return ret;
 			}
-			
+
 			/*frame queue*/
 			for(i=0; i<vd->frame_queue_size; ++i)
 			{
@@ -269,7 +269,7 @@ int alloc_v4l2_frames(v4l2_dev_t *vd)
 			 */
 			fprintf(stderr, "V4L2_CORE: (v4l2uvc.c) should never arrive (1)- exit fatal !!\n");
 			ret = E_UNKNOWN_ERR;
-			
+
 			if(vd->h264_last_IDR)
 				free(vd->h264_last_IDR);
 			vd->h264_last_IDR = NULL;
@@ -321,7 +321,7 @@ void clean_v4l2_frames(v4l2_dev_t *vd)
 	assert(vd != NULL);
 
 	int i = 0;
-	
+
 	for(i=0; i<vd->frame_queue_size; ++i)
 	{
 		vd->frame_queue[i].raw_frame = NULL;
@@ -489,13 +489,13 @@ static int demux_uvcH264(uint8_t *h264_data, uint8_t *buff, int size, int h264_m
 	/*asserts*/
 	assert(h264_data != NULL);
 	assert(buff != NULL);
-	
+
 	uint8_t *sp = NULL;
 	uint8_t *spl= NULL;
 	uint8_t *epl= NULL;
 	uint8_t *header = NULL;
 	uint8_t *ph264 = h264_data;
-	
+
 	//search for first APP4 marker
 	for(sp = buff; sp < buff + size - 2; ++sp)
 	{
@@ -506,19 +506,19 @@ static int demux_uvcH264(uint8_t *h264_data, uint8_t *buff, int size, int h264_m
 			break;
 		}
 	}
-	
-	/*(in big endian) 
+
+	/*(in big endian)
 	 *includes payload size + header + 6 bytes(2 length + 4 payload size)
 	 */
 	uint16_t length = 0;
 	length  = (uint16_t) spl[0] << 8;
 	length |= (uint16_t) spl[1];
-	
+
 	header = spl + 2;
 	/*in litle endian*/
 	uint16_t header_length = header[2];
 	header_length |= header[3] << 8;
-	
+
 	spl = header + header_length;
 	/*in litle endian*/
 	uint32_t payload_size = 0;
@@ -526,23 +526,23 @@ static int demux_uvcH264(uint8_t *h264_data, uint8_t *buff, int size, int h264_m
 	payload_size |= ((uint32_t) spl[1]) << 8;
 	payload_size |= ((uint32_t) spl[2]) << 16;
 	payload_size |= ((uint32_t) spl[3]) << 24;
-	
+
 	spl += 4; /*start of payload*/
 	epl = spl + payload_size; /*end of payload*/
-	
+
 	if(epl > buff + size)
 	{
 		fprintf(stderr, "V4L2_CORE: payload size bigger than buffer, clipped to buffer size (demux_uvcH264)\n");
 		epl = buff + size;
 	}
-	
+
 	sp = spl;
-	
+
 	uint32_t max_seg_size = 64*1024;
-	
+
 	/*copy first segment*/
 	length -= header_length + 6;
-	
+
 	if(length <= max_seg_size)
 	{
 		/*copy the segment to h264 buffer*/
@@ -550,7 +550,7 @@ static int demux_uvcH264(uint8_t *h264_data, uint8_t *buff, int size, int h264_m
 		ph264 += length;
 		sp += length;
 	}
-	
+
 	/*copy other segments*/
 	while( epl > sp)
 	{
@@ -558,35 +558,35 @@ static int demux_uvcH264(uint8_t *h264_data, uint8_t *buff, int size, int h264_m
 		   sp[1] != 0xE4)
 		{
 			fprintf(stderr, "V4L2_CORE: expected APP4 marker but none found (demux_uvcH264)\n");
-			return (ph264 - h264_data);	
+			return (ph264 - h264_data);
 		}
 		else
 		{
 			length  = (uint16_t) sp[2] << 8;
 			length |= (uint16_t) sp[3];
-			
+
 			length -= 2; /*remove the 2 bytes from length*/
 		}
-		
+
 		sp += 4; /*APP4 marker + length*/
-	
+
 		if((length != max_seg_size) && (verbosity > 1))
 		{
 			printf("V4L2_CORE: segment length is %i (demux_uvcH264)\n", length);
 		}
-		
+
 		/*copy the segment to h264 buffer*/
 		memcpy(ph264, sp, length);
 		ph264 += length;
 		sp += length;
-		
+
 		if((epl-sp) > 0 && (epl-sp < 4))
 		{
 			fprintf(stderr, "V4L2_CORE: payload ended unexpectedly (demux_uvcH264)\n");
 			return (ph264 - h264_data);
 		}
 	}
-	
+
 	if(epl-sp > 0)
 	{
 		fprintf(stderr, "V4L2_CORE: copy segment with %i bytes (demux_uvcH264)\n", (int) (epl-sp));
@@ -594,8 +594,8 @@ static int demux_uvcH264(uint8_t *h264_data, uint8_t *buff, int size, int h264_m
 		memcpy(ph264, sp, epl-sp);
 		ph264 += epl-sp;
 	}
-	
-	return (ph264 - h264_data); 
+
+	return (ph264 - h264_data);
 }
 
 /*
@@ -1035,3 +1035,35 @@ int decode_v4l2_frame(v4l2_dev_t *vd, v4l2_frame_buff_t *frame)
 
 	return ret;
 }
+
+int libav_decode(AVCodecContext *avctx, AVFrame *frame, int *got_frame, AVPacket *pkt)
+{
+#if LIBAVCODEC_VER_AT_LEAST(57,64)
+
+	int ret;
+
+	*got_frame = 0;
+
+	if (pkt)
+	{
+			ret = avcodec_send_packet(avctx, pkt);
+			// In particular, we don't expect AVERROR(EAGAIN), because we read all
+			// decoded frames with avcodec_receive_frame() until done.
+			if (ret < 0)
+					return ret == AVERROR_EOF ? 0 : ret;
+	}
+
+	ret = avcodec_receive_frame(avctx, frame);
+	if (ret < 0 && ret != AVERROR(EAGAIN) && ret != AVERROR_EOF)
+			return ret;
+	if (ret >= 0)
+			*got_frame = 1;
+
+	return 0;
+
+#else
+
+	return avcodec_decode_video2(dec_ctx, frame, got_picture, pkt);
+
+#endif
+}
diff --git a/gview_v4l2core/frame_decoder.h b/gview_v4l2core/frame_decoder.h
index 911740b..17fd9b7 100644
--- a/gview_v4l2core/frame_decoder.h
+++ b/gview_v4l2core/frame_decoder.h
@@ -27,6 +27,32 @@
 #include "gviewv4l2core.h"
 #include "v4l2_core.h"
 
+/*h264 and jpeg decoder (libavcodec)*/
+#ifdef HAVE_FFMPEG_AVCODEC_H
+#include <ffmpeg/avcodec.h>
+#else
+#include <libavcodec/avcodec.h>
+	#ifdef HAVE_LIBAVUTIL_VERSION_H
+#include <libavutil/version.h>
+#include <libavutil/imgutils.h>
+	#endif
+#include <libavutil/avutil.h>
+#endif
+
+#define LIBAVCODEC_VER_AT_LEAST(major,minor)  (LIBAVCODEC_VERSION_MAJOR > major || \
+                                              (LIBAVCODEC_VERSION_MAJOR == major && \
+                                               LIBAVCODEC_VERSION_MINOR >= minor))
+
+#ifdef LIBAVUTIL_VERSION_MAJOR
+#define LIBAVUTIL_VER_AT_LEAST(major,minor)  (LIBAVUTIL_VERSION_MAJOR > major || \
+                                              (LIBAVUTIL_VERSION_MAJOR == major && \
+                                               LIBAVUTIL_VERSION_MINOR >= minor))
+#else
+#define LIBAVUTIL_VER_AT_LEAST(major,minor) 0
+#endif
+
+int libav_decode(AVCodecContext *avctx, AVFrame *frame, int *got_frame, AVPacket *pkt);
+
 /*
  * Alloc image buffers for decoding video stream
  * args:
@@ -63,4 +89,4 @@ int decode_v4l2_frame(v4l2_dev_t *vd, v4l2_frame_buff_t *frame);
  */
 void clean_v4l2_frames(v4l2_dev_t *vd);
 
-#endif
\ No newline at end of file
+#endif
diff --git a/gview_v4l2core/jpeg_decoder.c b/gview_v4l2core/jpeg_decoder.c
index 21d2451..c3c3ae6 100644
--- a/gview_v4l2core/jpeg_decoder.c
+++ b/gview_v4l2core/jpeg_decoder.c
@@ -39,6 +39,7 @@
 
 #include "gviewv4l2core.h"
 #include "colorspaces.h"
+#include "frame_decoder.h"
 #include "jpeg_decoder.h"
 #include "gview.h"
 #include "../config.h"
@@ -117,9 +118,9 @@ typedef struct _jpeg_decoder_context_t
 	int width;
 	int height;
 	int pic_size;
-	
+
 	uint8_t *tmp_frame; //temp frame buffer
-	
+
 } jpeg_decoder_context_t;
 
 static jpeg_decoder_context_t *jpeg_ctx = NULL;
@@ -408,7 +409,7 @@ static int fillbits(struct in *inp, int le, unsigned int bi)
 {
 	/*asserts*/
 	assert(inp != NULL);
-	
+
 	if (inp->marker)
 	{
 		if (le <= 16)
@@ -419,7 +420,7 @@ static int fillbits(struct in *inp, int le, unsigned int bi)
 	{
 		int b = *inp->p++;
 		int m = 0;
-		
+
 		if (b == 0xff && (m = *inp->p++) != 0)
 		{
 			if (m == M_EOF)
@@ -499,7 +500,7 @@ static void decode_mcus(struct in *inp, int *dct, int n, struct scan *sc, int *m
 
 		hu = sc->huac.dhuff;
 		int i = 63;
-		
+
 		while (i > 0)
 		{
 			t = DEC_REC(inp, hu, r, t);
@@ -800,7 +801,7 @@ static int readtables(int till, int *isDHT)
 	{
 		if (getbyte() != 0xff)
 			return -1;
-		
+
 		int m = 0;
 
 		if ((m = getbyte()) == till)
@@ -986,19 +987,19 @@ int jpeg_init_decoder(int width, int height)
 		fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (jpeg_init_decoder): %s\n", strerror(errno));
 		exit(-1);
 	}
-	
+
 	jpeg_ctx->width = width;
 	jpeg_ctx->height = height;
 	jpeg_ctx->pic_size = width * height * 2; //yuyv
 	jpeg_ctx->codec_data = NULL;
-	
+
 	jpeg_ctx->tmp_frame = calloc(jpeg_ctx->pic_size, sizeof(uint8_t));
 	if(jpeg_ctx->tmp_frame == NULL)
 	{
 		fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (jpeg_init_decoder): %s\n", strerror(errno));
 		exit(-1);
 	}
-	
+
 	return E_OK;
 }
 
@@ -1021,7 +1022,7 @@ int jpeg_decode(uint8_t *out_buf, uint8_t *in_buf, int size)
 	/*asserts*/
 	assert(in_buf != NULL);
 	assert(out_buf != NULL);
-	
+
 	memcpy(jpeg_ctx->tmp_frame, in_buf, size);
 
 	struct jpeg_decdata *decdata;
@@ -1338,7 +1339,7 @@ void jpeg_close_decoder()
 {
 	if(jpeg_ctx == NULL)
 		return;
-	
+
 	free(jpeg_ctx->tmp_frame);
 	free(jpeg_ctx);
 
@@ -1347,38 +1348,6 @@ void jpeg_close_decoder()
 
 #else  //use libavcodec to decode mjpeg data
 
-/*h264 decoder (libavcodec)*/
-#ifdef HAVE_FFMPEG_AVCODEC_H
-#include <ffmpeg/avcodec.h>
-#else
-#include <libavcodec/avcodec.h>
-	#ifdef HAVE_LIBAVUTIL_VERSION_H
-#include <libavutil/version.h>
-#include <libavutil/imgutils.h>
-	#endif
-#include <libavutil/avutil.h>
-#endif 
-
-#define LIBAVCODEC_VER_AT_LEAST(major,minor)  (LIBAVCODEC_VERSION_MAJOR > major || \
-                                              (LIBAVCODEC_VERSION_MAJOR == major && \
-                                               LIBAVCODEC_VERSION_MINOR >= minor))
-
-#ifdef LIBAVUTIL_VERSION_MAJOR
-#define LIBAVUTIL_VER_AT_LEAST(major,minor)  (LIBAVUTIL_VERSION_MAJOR > major || \
-                                              (LIBAVUTIL_VERSION_MAJOR == major && \
-                                               LIBAVUTIL_VERSION_MINOR >= minor))
-#else
-#define LIBAVUTIL_VER_AT_LEAST(major,minor) 0
-#endif
-
-#if !LIBAVCODEC_VER_AT_LEAST(54,25)
-	#define AV_CODEC_ID_H264 CODEC_ID_H264
-#endif
-
-#if !LIBAVCODEC_VER_AT_LEAST(54,25)
-	#define AV_CODEC_ID_MJPEG CODEC_ID_MJPEG
-#endif
-
 typedef struct _codec_data_t
 {
 	AVCodec *codec;
@@ -1418,14 +1387,14 @@ int jpeg_init_decoder(int width, int height)
 		fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (jpeg_init_decoder): %s\n", strerror(errno));
 		exit(-1);
 	}
-	
+
 	codec_data_t *codec_data = calloc(1, sizeof(codec_data_t));
 	if(codec_data == NULL)
 	{
 		fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (jpeg_init_decoder): %s\n", strerror(errno));
 		exit(-1);
 	}
-	
+
 	codec_data->codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);
 	if(!codec_data->codec)
 	{
@@ -1520,34 +1489,34 @@ int jpeg_decode(uint8_t *out_buf, uint8_t *in_buf, int size)
 	AVPacket avpkt;
 
 	av_init_packet(&avpkt);
-	 	
+
 	avpkt.size = size;
 	avpkt.data = in_buf;
-	
+
 	codec_data_t *codec_data = (codec_data_t *) jpeg_ctx->codec_data;
 
-	int got_picture = 0;
-	int len = avcodec_decode_video2(codec_data->context, codec_data->picture, &got_picture, &avpkt);
+	int got_frame = 0;
+	int ret = libav_decode(codec_data->context, codec_data->picture, &got_frame, &avpkt);
 
-	if(len < 0)
+	if(ret < 0)
 	{
 		fprintf(stderr, "V4L2_CORE: (jpeg decoder) error while decoding frame\n");
-		return len;
+		return ret;
 	}
 
-	if(got_picture)
+	if(got_frame)
 	{
 #if LIBAVUTIL_VER_AT_LEAST(54,6)
 		av_image_copy_to_buffer(jpeg_ctx->tmp_frame, jpeg_ctx->pic_size,
                              (const uint8_t * const*) codec_data->picture->data, codec_data->picture->linesize,
                              codec_data->context->pix_fmt, jpeg_ctx->width, jpeg_ctx->height, 1);
 #else
-		avpicture_layout((AVPicture *) codec_data->picture, codec_data->context->pix_fmt, 
+		avpicture_layout((AVPicture *) codec_data->picture, codec_data->context->pix_fmt,
 			jpeg_ctx->width, jpeg_ctx->height, jpeg_ctx->tmp_frame, jpeg_ctx->pic_size);
 #endif
 		/* libavcodec output is in yuv422p */
         yuv422p_to_yu12(out_buf, jpeg_ctx->tmp_frame, jpeg_ctx->width, jpeg_ctx->height);
-	
+
 		return jpeg_ctx->pic_size;
 	}
 	else
@@ -1569,7 +1538,7 @@ void jpeg_close_decoder()
 {
 	if(jpeg_ctx == NULL)
 		return;
-		
+
 	codec_data_t *codec_data = (codec_data_t *) jpeg_ctx->codec_data;
 
 	avcodec_close(codec_data->context);
@@ -1588,7 +1557,7 @@ void jpeg_close_decoder()
 
 	if(jpeg_ctx->tmp_frame)
 		free(jpeg_ctx->tmp_frame);
-		
+
 	free(codec_data);
 	free(jpeg_ctx);
 
@@ -1596,5 +1565,3 @@ void jpeg_close_decoder()
 }
 
 #endif
-
-
diff --git a/gview_v4l2core/uvc_h264.c b/gview_v4l2core/uvc_h264.c
index 828ea89..331b256 100644
--- a/gview_v4l2core/uvc_h264.c
+++ b/gview_v4l2core/uvc_h264.c
@@ -33,35 +33,9 @@
 #include <assert.h>
 
 #include "gview.h"
+#include "frame_decoder.h"
 #include "../config.h"
 
-#ifdef HAVE_FFMPEG_AVCODEC_H
-#include <ffmpeg/avcodec.h>
-#else
-#include <libavcodec/avcodec.h>
-	#ifdef HAVE_LIBAVUTIL_VERSION_H
-#include <libavutil/version.h>
-#include <libavutil/imgutils.h>
-	#endif
-#include <libavutil/avutil.h>
-#endif 
-
-#define LIBAVCODEC_VER_AT_LEAST(major,minor)  (LIBAVCODEC_VERSION_MAJOR > major || \
-                                              (LIBAVCODEC_VERSION_MAJOR == major && \
-                                               LIBAVCODEC_VERSION_MINOR >= minor))
-
-#ifdef LIBAVUTIL_VERSION_MAJOR
-#define LIBAVUTIL_VER_AT_LEAST(major,minor)  (LIBAVUTIL_VERSION_MAJOR > major || \
-                                              (LIBAVUTIL_VERSION_MAJOR == major && \
-                                               LIBAVUTIL_VERSION_MINOR >= minor))
-#else
-#define LIBAVUTIL_VER_AT_LEAST(major,minor) 0
-#endif
-
-#if !LIBAVCODEC_VER_AT_LEAST(54,25)
-	#define AV_CODEC_ID_H264 CODEC_ID_H264
-#endif
-
 #include "uvc_h264.h"
 #include "v4l2_formats.h"
 
@@ -185,9 +159,9 @@ static int uvcx_video_encoder_reset(v4l2_dev_t *vd)
 
 	if((err = v4l2core_query_xu_control(
 		vd,
-		vd->h264_unit_id, 
-		UVCX_ENCODER_RESET, 
-		UVC_SET_CUR, 
+		vd->h264_unit_id,
+		UVCX_ENCODER_RESET,
+		UVC_SET_CUR,
 		&encoder_reset_req)) < 0)
 		fprintf(stderr, "V4L2_CORE: (UVCX_ENCODER_RESET) error: %s\n", strerror(errno));
 
@@ -215,10 +189,10 @@ static int uvcx_video_probe(v4l2_dev_t *vd, uint8_t query, uvcx_video_config_pro
 
 
 	if((err = v4l2core_query_xu_control(
-		vd, 
-		vd->h264_unit_id, 
-		UVCX_VIDEO_CONFIG_PROBE, 
-		query, 
+		vd,
+		vd->h264_unit_id,
+		UVCX_VIDEO_CONFIG_PROBE,
+		query,
 		uvcx_video_config)) < 0)
 		fprintf(stderr, "V4L2_CORE: (UVCX_VIDEO_CONFIG_PROBE) error: %s\n", strerror(errno));
 
@@ -244,7 +218,7 @@ static int uvcx_video_commit(v4l2_dev_t *vd, uvcx_video_config_probe_commit_t *u
 	int err = 0;
 
 	if((err = v4l2core_query_xu_control(
-		vd, 
+		vd,
 		vd->h264_unit_id,
 		UVCX_VIDEO_CONFIG_COMMIT,
 		UVC_SET_CUR,
@@ -271,10 +245,10 @@ uint8_t get_uvc_h624_unit_id (v4l2_dev_t *vd)
 {
 	if(verbosity > 1)
 		printf("V4L2_CORE: checking for UVCX_H264 unit id\n");
-	
-	uint8_t guid[16] = GUID_UVCX_H264_XU;	
+
+	uint8_t guid[16] = GUID_UVCX_H264_XU;
 	vd->h264_unit_id = get_guid_unit_id (vd, guid);
-	
+
 	return vd->h264_unit_id;
 }
 
@@ -1006,10 +980,10 @@ int h264_init_decoder(int width, int height)
 	 * we wish to have smaller code)
 	 */
 	avcodec_register_all();
-	
+
 	if(h264_ctx != NULL)
 		h264_close_decoder();
-	
+
 	h264_ctx = calloc(1, sizeof(h264_decoder_context_t));
 	if(h264_ctx == NULL)
 	{
@@ -1025,7 +999,7 @@ int h264_init_decoder(int width, int height)
 		h264_ctx = NULL;
 		return E_NO_CODEC;
 	}
-	
+
 #if LIBAVCODEC_VER_AT_LEAST(53,6)
 	h264_ctx->context = avcodec_alloc_context3(h264_ctx->codec);
 	avcodec_get_context_defaults3 (h264_ctx->context, h264_ctx->codec);
@@ -1038,7 +1012,7 @@ int h264_init_decoder(int width, int height)
 		fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (h264_init_decoder): %s\n", strerror(errno));
 		exit(-1);
 	}
-	
+
 	h264_ctx->context->flags2 |= CODEC_FLAG2_FAST;
 	h264_ctx->context->pix_fmt = AV_PIX_FMT_YUV420P;
 	h264_ctx->context->width = width;
@@ -1058,7 +1032,7 @@ int h264_init_decoder(int width, int height)
 		h264_ctx = NULL;
 		return E_NO_CODEC;
 	}
-	
+
 #if LIBAVCODEC_VER_AT_LEAST(55,28)
 	h264_ctx->picture = av_frame_alloc();
 	av_frame_unref(h264_ctx->picture);
@@ -1102,30 +1076,30 @@ int h264_decode(uint8_t *out_buf, uint8_t *in_buf, int size)
 	AVPacket avpkt;
 
 	av_init_packet(&avpkt);
-	
+
 	avpkt.size = size;
 	avpkt.data = in_buf;
 
-	int got_picture = 0;
-	int len = avcodec_decode_video2(h264_ctx->context, h264_ctx->picture, &got_picture, &avpkt);
+	int got_frame = 0;
+	int ret = libav_decode(h264_ctx->context, h264_ctx->picture, &got_frame, &avpkt);
 
-	if(len < 0)
+	if(ret < 0)
 	{
 		fprintf(stderr, "V4L2_CORE: (H264 decoder) error while decoding frame\n");
-		return len;
+		return ret;
 	}
 
-	if(got_picture)
+	if(got_frame)
 	{
 #if LIBAVUTIL_VER_AT_LEAST(54,6)
 		av_image_copy_to_buffer(out_buf, h264_ctx->pic_size,
                              (const unsigned char * const*) h264_ctx->picture->data, h264_ctx->picture->linesize,
                              h264_ctx->context->pix_fmt, h264_ctx->width, h264_ctx->height, 1);
 #else
-		avpicture_layout((AVPicture *) h264_ctx->picture, h264_ctx->context->pix_fmt, 
+		avpicture_layout((AVPicture *) h264_ctx->picture, h264_ctx->context->pix_fmt,
 			h264_ctx->width, h264_ctx->height, out_buf, h264_ctx->pic_size);
 #endif
-		return len;
+		return ret;
 	}
 	else
 		return 0;
-- 
2.15.0

